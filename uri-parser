#!/bin/sh

## Program Tracking ##

program_command="uri-parser"
program_version="3.2.0"
program_created="2015-05-31"
program_updated="2016-02-13"
program_license="GPL"
program_contact="Joel Parker Henderson (joel@joelparkerhenderson.com)"
program_variant="$program_command version $program_version updated $program_updated"

## Help Function ##

help(){
cat << END
uri-parser:
parse a URI to its parts.

Syntax:

    uri-parser [options] <uri> ...

Examples:

    $ uri-parser --host http://example.com/index.html
    example.com

    $ uri-parser --path http://example.com/index.html
    /index.html

## Options ##

General options:

  * \`-h\`, \`--help\`: show help message
  * \`-V\`, \`--version\`: show version message

Output options:

  * \`--uri\`: the entire URI
  * \`--scheme\`, \`--protocol\`: the scheme a.k.a. protocol, such as "http"
  * \`--authority\`: the authority, such as "alice:secret@www.example.com:80"
  * \`--userinfo\`: the username and password, such as "alice:secret"
  * \`--username\`: the username, such as "alice"
  * \`--password\`: the password, such as "secret"
  * \`--hostinfo\`: the host and port, such as "www.example.com:80"
  * \`--host\`: the host, such as "www.example.com"
  * \`--tld``: the TLD a.ka. top level domain, such as "com"
  * \`--port\`: the port, such as "80"
  * \`--path\`: the path part, such as "/a/b/c/index.html?key=val#123"
  * \`--dirname\`: the path directory name, such as "/a/b/c"
  * \`--basename\`: the path base name, such as "index.html"
  * \`--query\`: the query part, such as "key=val"
  * \`--fragment\`, \`--anchor\`: the fragment a.k.a. anchor, such as an id.
  * \`--hierarchy\`: the hierarchical part, which is the authority and path
  * \`--holarchy\`: the non-hierarchical part, which is the query and fragment

## URI Scheme Details ##

Every URI is made of parts. The parts are described in the URI RFC specification, and there is a summary at http://en.wikipedia.org/wiki/URI_scheme

Example:

    http://www.example.com/index.html
    └─┬─┘  └──────┬──────┘ └───┬────┘
    scheme       host         path

Example with more parts:

    http://elizabeth:opensesame@www.example.com:10000/aa/bb/cc/index.html?key=val#identifier
    └─┬─┘  └───┬───┘ └───┬────┘ └──────┬──────┘└─┬──┘└─────────┬────────┘ └──┬──┘ └───┬────┘
    scheme  username  password        host      port          path          query   fragment
           └─────────┬────────┘ └─────────┬─────────┘└──────────────────┬──────────────────┘
                  userinfo             hostinfo                      pathinfo
           └───────────────────┬────────────────────┘
                           authority
           └───────────────────────────────┬────────────────────────────┘ └───────┬────────┘
                                        hierarchy                              holarchy

The path part may have a directory name and a base name:

    http://www.example.com/aa/bb/cc/index.html
                          └───┬───┘ └───┬────┘
                            dirname  basename
                          └─────────┬────────┘
                                   path

Synonyms:

  * scheme, protocol
  * fragment, anchor

## Caution ##

This software is currently alpha quality.

It is suitable for a first look by developers so we can feedback and make improvements.

Do not use this current version for production systems.

Command: $program_command
Version: $program_version
Created: $program_created
Updated: $program_updated
License: $program_license
Contact: $program_contact
END
}

## Essential Functions ##

out () { printf %s\\n "$*" ; }
err () { >&2 printf %s\\n "$*" ; }
die () { >&2 printf %s\\n "$*" ; exit 1 ; }
die_opt_unk() { die "Option $1 is unknown" ; }
die_opt_arg() { die "Option $1 needs an argument" ; }

## Defaults ##

parts=""
fs=${FS:- }

## Options ##

while [ $# -gt 0 ]; do
    case $1 in
        -- )
            shift
            break
            ;;
        -h | --help )
            help
            exit 0
            ;;
        -V | --version )
            out $program_variant
            exit 0
            ;;
        --uri | \
        --scheme | \
        --protocol | \
        --hierarchical | \
        --authority | \
        --userinfo | \
        --username | \
        --password | \
        --hostinfo | \
        --host | \
        --tld | \
        --port | \
        --path | \
        --dirname | \
        --basename | \
        --query | \
        --fragment | \
        --anchor | \
        --hierarchy | \
        --holarchy )
            parts="$parts ${1#--}"
            ;;
        -?*)
            die_opt_unk $1
            ;;
        *)
            break
    esac
    shift
done

[ $# -eq 0 ] && help && exit 0

## Main ##

for uri in "$@"; do

  ## Clear ##

  name=""
  authority=""
  userinfo=""
  username=""
  password=""
  hostinfo=""
  host=""
  tld=""
  port=""
  path=""
  dirname=""
  basename=""
  query=""
  fragment=""
  hierarchy=""
  holarchy=""

  ## Parse the URI to its parts ##

  scheme=${uri%%:*}; s=${uri#*:}

  if [[ $s = "//"* ]]; then
      s=${s#//}
      authority=${s%%/*}
      path_query_fragment=${s:${#authority}}
      if [ -n "${authority:-}" ]; then
          hierarchy="$authority"
          if [[ $authority == *@* ]]; then
              userinfo=${authority%@*}
              hostinfo=${authority##*@}
          else
              userinfo=""
              hostinfo="$authority"
          fi
          if [ -n "$userinfo" ]; then
              username=${userinfo%%:*}
              password=${userinfo#*:}
          fi
          if [ -n "$hostinfo" ]; then
              host=${hostinfo%:*}
              if [[ -n $host ]]; then
                  tld=${host##*.}
              fi
              if [[ $hostinfo == *:* ]]; then
                  port=${hostinfo##*:}
              fi
          fi
      fi
      if [ -n "${path_query_fragment:-}" ]; then
          path=${path_query_fragment}
          path=${path%%\?*}
          path=${path%%#*}
          hierarchy="$hierarchy$path"
          dirname=$(dirname "$path")
          basename=$(basename "$path")
          if [[ $path_query_fragment == *?* ]]; then
              query=${path_query_fragment##*\?}
              query=${query%%#*}
              holarchy="$query"
          fi
          if [[ $path_query_fragment == *#* ]]; then
              fragment=${path_query_fragment##*\#}
              holarchy="$holarchy#$fragment"
          fi
      fi
  else
      path=$s
  fi

  if [ -z "$parts" ];  then
      [ -z "$uri" ]          || out "uri:$uri"
      [ -z "$scheme" ]       || out "scheme:$scheme"
      [ -z "$authority" ]    || out "authority:$authority"
      [ -z "$userinfo" ]     || out "userinfo:$userinfo"
      [ -z "$username" ]     || out "username:$username"
      [ -z "$password" ]     || out "password:$password"
      [ -z "$hostinfo" ]     || out "hostinfo:$hostinfo"
      [ -z "$host" ]         || out "host:$host"
      [ -z "$tld" ]          || out "tld:$tld"
      [ -z "$port" ]         || out "port:$port"
      [ -z "$path" ]         || out "path:$path"
      [ -z "$dirname" ]      || out "dirname:$dirname"
      [ -z "$basename" ]     || out "basename:$basename"
      [ -z "$query" ]        || out "query:$query"
      [ -z "$fragment" ]     || out "fragment:$fragment"
      [ -z "$hierarchy" ]    || out "hierarchy:$hierarchy"
      [ -z "$holarchy" ]     || out "holarchy:$holarchy"
  else
      s=""
      for part in $parts; do
          case $part in
              uri )          s="$s$fs$uri" ;;
              scheme )       s="$s$fs$scheme" ;;
              protocol )     s="$s$fs$scheme" ;;
              authority )    s="$s$fs$authority" ;;
              userinfo )     s="$s$fs$userinfo" ;;
              username )     s="$s$fs$username" ;;
              password )     s="$s$fs$password" ;;
              hostinfo )     s="$s$fs$hostinfo" ;;
              host )         s="$s$fs$host" ;;
              tld )          s="$s$fs$tld" ;;
              port )         s="$s$fs$port" ;;
              path )         s="$s$fs$path" ;;
              dirname )      s="$s$fs$dirname" ;;
              basename )     s="$s$fs$basename" ;;
              query )        s="$s$fs$query" ;;
              fragment )     s="$s$fs$fragment" ;;
              anchor )       s="$s$fs$fragment" ;;
              hierarchy )    s="$s$fs$hierarchy" ;;
              holarchy )     s="$s$fs$holarchy" ;;
          esac
      done
      s=${s#$fs}
      out "$s"
  fi
done
